<div class="q-election-executive" style="opacity: 0;">
  <Header title='{item.title}' hideTitle='{hideTitle}' subtitle='{item.subtitle}' candidatesInfo='{candidatesInfo}' />
  <Legend candidatesInfo='{candidatesInfo}' withErrorMargin='{withErrorMargin}' hasErrorMargin='{hasErrorMargin}' errorMarginLabels='{errorMarginLabels}'></Legend>
  <div class="q-election-executive-container">
    <div class="q-election-executive-candidates">
      {#each candidatesInfo.sortedCandidates as candidate, index}
      <Candidate candidate='{candidate}' isPercentage='{item.isPercentage}' isImagePresent='{candidatesInfo.isImagePresent}'
        isLastCandidate='{index === candidatesInfo.sortedCandidates.length - 1}' majority='{majority}' maxNumber='{maxNumber}' withErrorMargin='{withErrorMargin}' maxErrorMarginValue='{maxErrorMarginValue}'/> 
        {#if item.availableSeats === index+1}
          <div class="q-election-executive-available-seats s-color-gray-5">
            <div class="s-font-note-s q-election-executive-available-seats-text">Verf√ºgbare Sitze: {item.availableSeats}</div>
          </div>
        {/if}
      {/each}
    </div>
    {#if candidatesInfo.others}
    <div class="q-election-executive-others">
      <Candidate candidate='{candidatesInfo.others}' isPercentage='{item.isPercentage}' isImagePresent='{candidatesInfo.isImagePresent}'
        isOthers='true' majority='{majority}' maxErrorMarginValue='{maxErrorMarginValue}' maxNumber='{maxNumber}'/>
    </div>
    {/if}
  </div>
  <Footer majority='{majority}' sources='{item.sources}' notes='{item.notes}' updatedDate='{item.updatedDate}'
    hideUpdatedDate='{hideUpdatedDate}' />
</div>

<script>
  import Header from './Header.html';
  import Legend from './Legend.html';
  import Candidate from './Candidate.html';
  import Footer from './Footer.html';

  export default {
    computed: {
      hideTitle: ({ toolRuntimeConfig }) => {
        return toolRuntimeConfig.displayOptions && toolRuntimeConfig.displayOptions.hideTitle;
      },
      candidates: ({ item }) => {
        return item.candidates;
      },
      majority: ({ item }) => {
        return item.majority;
      },
      maxVotes: ({ item }) => {
        const maxResult = Math.max(...item.candidates.map(candidate => { 
          if (candidate.votes !== undefined) {
            return candidate.votes;
          }
          return 0;
        }));
        if (item.threshold > maxResult) {
          return item.threshold;
        }
        return maxResult;
      },
      maxErrorMarginValue: ({ item }) => {
        const maxErrorMarginValue = Math.max(...item.candidates.map(candidate => { 
          if (candidate.errorMargin && candidate.errorMargin.upper !== undefined) {
            return candidate.errorMargin.upper;
          }
          return 0;
        }));
        if (item.threshold > maxErrorMarginValue) {
          return item.threshold;
        }
        return maxErrorMarginValue;
      },
      titleClassAttribute: ({ toolRuntimeConfig }) => {
        if (toolRuntimeConfig.displayOptions && toolRuntimeConfig.displayOptions.hideTitle) {
          return 'q-election-executive-title--hidden';
        }
        return '';
      },
      sortedCandidates: ({ candidates, withErrorMargin }) => {
        if (candidates) {
          if (withErrorMargin) {
            return candidates.sort(function(candidateA, candidateB) {
              // if both have no errorMargin set, keep the order
              if (candidateA.errorMargin === undefined && candidateB.errorMargin === undefined) {
                return 0;
              } // if only A has no errorMargin, sort B before A
              if (candidateA.errorMargin === undefined && candidateB.errorMargin !== undefined) {
                return 1;
              }
              // if only A has no bestGuess or B bestGuess is higher than A, sort B before A
              if ((candidateA.errorMargin.bestGuess === undefined && candidateB.errorMargin.bestGuess !== undefined) || (candidateA.errorMargin.bestGuess < candidateB.errorMargin.bestGuess)) {
                return 1;
              }
              // otherwise sort A before B
              return -1;
            });
          } else {
            return candidates.sort(function(candidateA, candidateB) {
              if ((candidateA.votes === undefined && candidateB.votes === undefined) || candidateA.votes === candidateB.votes) {
                return 0;
              }
              if ((candidateA.votes === undefined && candidateB.votes !== undefined) || (candidateA.votes < candidateB.votes)) {
                return 1;
              }
              return -1;
            });
          }
        }
        return [];
      },
      candidatesInfo: ({ sortedCandidates, majority, maxVotes, withErrorMargin, maxErrorMarginValue, maxNumber }) => {
        // enhance candidates object with additional information
        let isPrevious = false;
        let isElected = false;
        let isDropped = false;
        let isImagePresent = false;

        let hasVotes = maxVotes > 0;

        sortedCandidates.forEach(candidate => {
          if (candidate.picture !== undefined && candidate.picture.url !== undefined) {
            isImagePresent = true;
          }
          // define width and color of each candidate's bar
          let width = '1px';
          let colorStyle = '';
          let colorClass = '';
          const defaultColor = 's-viz-color-one-5';

          // the width is only used later if we do not have withErrorMargin
          if (hasVotes && candidate.votes && candidate.votes > 0) {
            const widthPercentage = (candidate.votes * 100 / maxNumber).toFixed(2);
            width = widthPercentage + '%';
          }
          candidate.width = width;

          if (candidate.status === "elected" || candidate.status === "undefined") {
            candidate.opacity = 1;
          } else {
            candidate.opacity = 0.5;
          }

          if (candidate.color) {
              if (candidate.color.classAttribute) {
                colorClass = candidate.color.classAttribute;
              } else if (candidate.color.colorCode) {
                colorStyle = 'color: ' + candidate.color.colorCode + ';';
              }
          }

          if (!colorClass && !colorStyle) {
            colorClass = defaultColor;
          }

          candidate.colorClass = colorClass;
          candidate.colorStyle = colorStyle;
          // check if we have previous, elected or dropped candidates for footer info
          if (candidate.isPrevious) {
            isPrevious = true;
            if (candidate.status === "not elected") {
              isDropped = true;
            }
          }
          if (candidate.status === "elected") {
            isElected = true;
          }

        })

        // define info object which contains general information and sorted candidates
        const candidatesInfo = {
          hasVotes: hasVotes,
          maxNumber: maxNumber,
          isPrevious: isPrevious,
          isElected: isElected,
          isDropped: isDropped,
          isImagePresent: isImagePresent,
          sortedCandidates: sortedCandidates
        }

        // process the group of other candidates differently - not part of the majority
        let othersIndex = sortedCandidates.findIndex(candidate => {
          let othersPattern = /((.*(A|a)ndere.*)|(.*(S|s)onstig.*))/;
          return othersPattern.test(candidate.name);
        })
        if (othersIndex >= 0) {
          let others = sortedCandidates.splice(othersIndex, 1);
          candidatesInfo.others = others[0];
          candidatesInfo.hasOthers = true;
        }

        return candidatesInfo;
      },
      maxNumber: ({ withErrorMargin, maxVotes, maxErrorMarginValue, majority }) => {
        let maxNumber;
        if (withErrorMargin) {
          maxNumber = maxErrorMarginValue;
        } else {
          maxNumber = maxVotes;
        }
        // if the majority is higher than maxErrorMarginValue or maxVotes, it is the highest number
        if (majority !== undefined && (majority > maxNumber || Number.isNaN(maxNumber))) {
          maxNumber = majority;
        }
        return maxNumber;
      },
      hideUpdatedDate: ({ item }) => {
        return item.options && item.options.hideUpdatedDate;
      },
      withErrorMargin: ({ item }) => {
        return item.withErrorMargin;
      },
      errorMarginLabels: ({ item }) => {
        return item.errorMarginLabels;
      },
      hasErrorMargin: ({ item }) => {
        return item.candidates.some(candidate => {
          return candidate.errorMargin && candidate.errorMargin.lower !== undefined && candidate.errorMargin.upper !== undefined
        });
      },
    },

    components: {
      Header,
      Legend,
      Candidate,
      Footer
    }
  };
</script>
