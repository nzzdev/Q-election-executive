<div class="q-election-executive" style="opacity: 0;">
  <Header title='{{item.title}}' hideTitle='{{hideTitle}}' subtitle='{{item.subtitle}}' />
  <div class="q-election-executive-container">
    <div class="q-election-executive-candidates {{majorityOffset}}">
      {{#each candidatesInfo.sortedCandidates as candidate, index}}
      <Candidate candidate='{{candidate}}' isPercentage='{{item.isPercentage}}' fullWidth='{{fullWidth}}' isImagePresent='{{candidatesInfo.isImagePresent}}'
        isLastCandidate='{{index === candidatesInfo.sortedCandidates.length - 1}}' majority='{{majority}}' base='{{majorityBase}}'
      /> {{/each}}
    </div>
    {{#if candidatesInfo.others}}
    <div class="q-election-executive-others">
      <Candidate candidate='{{candidatesInfo.others}}' isPercentage='{{item.isPercentage}}' fullWidth='{{fullWidth}}' isImagePresent='{{candidatesInfo.isImagePresent}}'
        isOthers='true' majority='{{majority}}' />
    </div>
    {{/if}}
  </div>
  <Footer majority='{{majority}}' candidatesInfo='{{candidatesInfo}}' sources='{{item.sources}}' notes='{{item.notes}}' updatedDate='{{item.updatedDate}}'
    hideUpdatedDate='{{hideUpdatedDate}}' />
</div>

<script>
  import Header from './Header.html';
  import Candidate from './Candidate.html';
  import Footer from './Footer.html';

  export default {
    computed: {
      hideTitle: (toolRuntimeConfig) => {
        return toolRuntimeConfig.displayOptions && toolRuntimeConfig.displayOptions.hideTitle;
      },
      candidates: (item) => {
        return item.candidates;
      },
      majority: (item) => {
        return item.majority;
      },
      titleClassAttribute: (toolRuntimeConfig) => {
        if (toolRuntimeConfig.displayOptions && toolRuntimeConfig.displayOptions.hideTitle) {
          return 'q-election-executive-title--hidden';
        }
        return '';
      },
      sortedCandidates: (candidates) => {
        if (candidates) {
          return candidates.sort(function(candidateA, candidateB) {
            if ((candidateA.votes === undefined && candidateB.votes === undefined) || candidateA.votes === candidateB.votes) {
              return 0;
            }
            if ((candidateA.votes === undefined && candidateB.votes !== undefined) || (candidateA.votes < candidateB.votes)) {
              return 1;
            }
            return -1;
          })
        }
        return [];
      },
      candidatesInfo: (sortedCandidates, majority) => {
        // enhance candidates object with additional information
        let isPrevious = false;
        let isElected = false;
        let isDropped = false;
        let isImagePresent = false;

        // if there are already any votes the first candidate 
        // of sorted list of candidates has max votes
        let maxVotes = 0;
        if (sortedCandidates[0] && sortedCandidates[0].votes) {
          maxVotes = sortedCandidates[0].votes;
        }

        let hasVotes = maxVotes > 0;
        let maxNumber = maxVotes;
        if (majority !== undefined && majority > maxVotes) {
          maxNumber = majority;
        }

        sortedCandidates.forEach(candidate => {
          if ((candidate.image !== undefined && candidate.image.base64 !== undefined) || (candidate.picture !== undefined && candidate.picture.url !== undefined)) {
            isImagePresent = true;
          }
          // define width and color of each candidate's bar
          let width = '1px';
          let colorStyle = '';
          let colorClass = '';
          const defaultColor = {
            light: 's-viz-color-one-3',
            full: 's-viz-color-one-5'
          }
          if (hasVotes && candidate.votes && candidate.votes > 0) {
            let widthPercentage = (candidate.votes * 100 / maxNumber).toFixed(2);
            width = widthPercentage + '%';
          }
          candidate.width = width;

          let colorDef;
          if (candidate.status === "elected" || candidate.status === "undefined") {
            colorDef = 'full';
          } else {
            colorDef = 'light';
          }

          if (candidate.color) {
            if (candidate.color[colorDef]) {
              if (candidate.color[colorDef].classAttribute) {
                colorClass = candidate.color[colorDef].classAttribute;
              } else if (candidate.color[colorDef].colorCode) {
                colorStyle = 'color: ' + candidate.color[colorDef].colorCode + ';';
              }
            }
          }

          if (!colorClass && !colorStyle) {
            colorClass = defaultColor[colorDef];
          }

          candidate.colorClass = colorClass;
          candidate.colorStyle = colorStyle;
          // check if we have previous, elected or dropped candidates for footer info
          if (candidate.isPrevious) {
            isPrevious = true;
            if (candidate.status === "not elected") {
              isDropped = true;
            }
          }
          if (candidate.status === "elected") {
            isElected = true;
          }

          // add grayscale class for image and color class for text
          // if candidate is not elected
          if (candidate.status === "not elected") {
            candidate.imageClassAttribute = "q-election-executive-item-image-gray";
            candidate.textClassAttribute = "s-color-gray-7";
          } else {
            candidate.imageClassAttribute = "";
            candidate.textClassAttribute = "";
          }
        })

        // define info object which contains general information and sorted candidates
        const candidatesInfo = {
          hasVotes: hasVotes,
          maxNumber: maxNumber,
          isPrevious: isPrevious,
          isElected: isElected,
          isDropped: isDropped,
          isImagePresent: isImagePresent,
          sortedCandidates: sortedCandidates
        }

        // process the group of other candidates differently - not part of the majority
        let othersIndex = sortedCandidates.findIndex(candidate => {
          let othersPattern = /((.*(A|a)ndere.*)|(.*(S|s)onstig.*))/;
          return othersPattern.test(candidate.name);
        })
        if (othersIndex >= 0) {
          let others = sortedCandidates.splice(othersIndex, 1);
          candidatesInfo.others = others[0];
          candidatesInfo.hasOthers = true;
        }

        return candidatesInfo;
      },
      fullWidth: (candidatesInfo) => {
        if (candidatesInfo.isImagePresent) {
          return ""
        }
        else {
          return "width: 100%";
        }
      },
      majorityBase: (candidatesInfo, majority) => {
        let majorityBase = candidatesInfo.maxNumber;
        if (!candidatesInfo.hasVotes) {
          majorityBase = majority;
        }
        return majorityBase;
      },
      hideUpdatedDate: (item) => {
        return item.options && item.options.hideUpdatedDate;
      }
    },

    components: {
      Header,
      Candidate,
      Footer
    }
  };
</script>
