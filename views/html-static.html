<div class="q-item-container s-q-item">
  <Header title='{{title}}' subtitle='{{subtitle}}'/>
  <div class="q-election-executive">
    <MajorityInfo majority='{{majority}}' maxNumber='{{enhancedCandidates.candidatesInfo.maxNumber}}' hasVotes='{{enhancedCandidates.candidatesInfo.hasVotes}}'/>
    <Candidates candidates ='{{enhancedCandidates}}' isPercentage='{{isPercentage}}'/>
  </div>
  <Footer majority='{{majority}}' candidatesInfo='{{enhancedCandidates.candidatesInfo}}' sources='{{sources}}' notes='{{notes}}' updatedDate='{{updatedDate}}'/>
</div>

<script>
  import Header from './Header.html';
  import MajorityInfo from './MajorityInfo.html';
  import Candidates from './Candidates.html';
  import Footer from './Footer.html';

  export default {
    computed: {
      sortedCandidates: (candidates) => {
        if (candidates) {
          return candidates.sort(function(candidateA, candidateB) {
            if ((candidateA.votes === undefined && candidateB.votes === undefined) || candidateA.votes === candidateB.votes) {
              return 0;
            }
            if ((candidateA.votes === undefined && candidateB.votes !== undefined) || (candidateA.votes < candidateB.votes)) {
              return 1;
            }
            return -1;
          })
        }
        return [];
      },
      enhancedCandidates: (sortedCandidates, majority) => {
        // enhance candidates object with additional information
        let isPrevious = false;
        let isElected = false;
        let isDropped = false;
        let isImagePresent = false;

        // if there are already any votes the first candidate 
        // of sorted list of candidates has max votes
        let maxVotes = 0;
        if (sortedCandidates[0] && sortedCandidates[0].votes) {
          maxVotes = sortedCandidates[0].votes;
        }

        let hasVotes = maxVotes > 0;
        let maxNumber = maxVotes;
        if (majority !== undefined && majority > maxVotes) {
          maxNumber = majority; 
        }

        sortedCandidates.forEach(candidate => {
          if (candidate.image !== undefined && candidate.image.base64 !== undefined) {
            isImagePresent = true;
          }
          // define width and color of each candidate's bar
          let width = '1px';
          let colorStyle = '';
          let colorClass = '';
          if (hasVotes && candidate.votes && candidate.votes > 0) {
            let widthPercentage = (candidate.votes * 100 / maxNumber).toFixed(2);
            width = widthPercentage + '%';
          }
          candidate.width = width;
          if (candidate.color) {
            let colorDef;
            if (candidate.status === "elected" || candidate.status === "undefined") {
              colorDef = 'full';
            } else {
              colorDef = 'light';
            }
            if (candidate.color[colorDef]) {
              if (candidate.color[colorDef].classAttribute) {
                colorClass = candidate.color[colorDef].classAttribute;
              } else {
                colorStyle = 'color: ' + candidate.color[colorDef].colorCode + ';'; 
              }
            }
          }
          candidate.colorClass = colorClass;
          candidate.colorStyle = colorStyle;
          // check if we have previous, elected or dropped candidates for footer info
          if(candidate.isPrevious) {
            isPrevious = true;
            if (candidate.status === "not elected") {
              isDropped = true; 
            }
          }
          if (candidate.status === "elected") {
            isElected = true;
          }

          // add grayscale class for image and color class for text
          // if candidate is not elected
          if (candidate.status === "not elected") {
            candidate.imageClassAttribute = "q-election-executive-item-image-gray";
            candidate.textClassAttribute = "s-color-gray-7";
          } else {
            candidate.imageClassAttribute = "";
            candidate.textClassAttribute = "";
          }
        })

        sortedCandidates.candidatesInfo = {
          hasVotes: hasVotes,
          maxNumber: maxNumber,
          isPrevious: isPrevious,
          isElected: isElected,
          isDropped: isDropped,
          isImagePresent: isImagePresent
        };

        return sortedCandidates;
      }
    },

    components: {
      Header,
      MajorityInfo,
      Candidates,
      Footer
    }
  };
</script>

