<div class="q-item-container">
  <h3 class="s-q-item__title">{{title}}</h3>
  <div class="q-election-executive-info s-font-note">
      {{#if intermediate}}Zwischenergebnis, {{/if}}Update {{updateInfo}}{{#if subtitle}}, {{subtitle}}{{/if}}
  </div>
  <div class="q-election-executive" style="height: {{numberCandidates * (40 + 8)}};">
    {{#if majority && maxResult > 0}}
      <div class="q-election-executive-majority" style="left: {{majority * 100 / maxResult}}%; height: {{numberCandidates * (40 + 8)}};">
        <!-- maybe correct per 1px left -->
        <div class="q-election-executive-majority-arrow" style="top: {{(numberCandidates * (40 + 8)) - 4}};"></div>
        <!-- maybe with switch to left if text is not fitting to right -->
        <div class="q-election-executive-majority-label s-font-note-s" style="left: {{majority * 100 / maxResult}}%; top: {{numberCandidates * (40 + 8)}};">
          <div class="q-election-executive-majority-label-text" style="left: calc({{majority * 100 / maxResult}}% - 135px);">
            <div>Absolutes Mehr</div>
            <div>{{majority}} Stimmen</div>
          </div>
        </div>
      </div>
    {{/if}}
    {{#each candidates as candidate}}
      <div class="q-election-executive-item">
        <div class="q-election-executive-item-image">
          <!-- replace with right image handling -> for testing purposes atm -->
          <img src="http://storytelling.nzz.ch/bundesrat/portrait_bw/doris-leuthard.png"/>
        </div>
        <div class="q-election-executive-item-info">
          {{#if candidate.votes}}
            <div class="q-election-executive-item-bar" style="background-color: {{candidate.colour}}; width: {{candidate.votes * 100 / maxResult}}%;"></div>
          {{else}}
            <div class="q-election-executive-item-bar" style="background-color: {{candidate.colour}}; width: 1px;"></div>
          {{/if}}
          <div class="q-election-executive-item-name">
            <span class="s-font-note-s s-font-note-s--strong ">{{candidate.name}}</span>
            <span class="s-font-note-s">{{candidate.party}}</span>
          </div>
          {{#if candidate.votes}}
            <div class="s-font-note-s s-font-note-s--strong q-election-executive-item-votes">{{candidate.votes}}</div>
          {{/if}}
        </div>
      </div>
    {{/each}}
  </div>
  <div class="q-election-executive-footer">
    {{#if majority && maxResult > 0}}
      <div class="q-election-executive-majority-gap"></div>
    {{/if}}
    {{#if notes}}
      <div class="q-election-executive-notes"></div>
    {{/if}}
    {{#if sources.length > 0}}
      <div class="q-election-executive-sources s-font-note-s s-font-note-s--light">
         {{#if sources.length > 1}} 
          Quellen: 
        {{else}} 
          Quelle: 
        {{/if}} 
        {{#each sources as source, index}}
          <!-- 	If you separate DOM siblings with newlines whitespaces cannot be removed by svelte renderer
                To avoid unwanted whitespaces around commas separating each source, we keep render infos for sources at one line here.
                See also: https://github.com/sveltejs/svelte/issues/189  -->
          {{#if source.text !== ''}}{{#if source.validHref}}<a href="{{source.href}}" target="blank" rel="noopener noreferrer">{{source.text}}</a>{{else}}{{source.text}}{{/if}}{{#if index !== sources.length - 1 && sources[index + 1] !== ''}}, {{/if}}{{/if}} 
        {{/each}}
      </div>
    {{/if}}
  </div>
</div>

<script>
  export default {
    computed: {
      maxResult: (candidates, majority) => {
        let maxResult = 0;
        candidates.forEach((candidate) => {
          if (candidate.votes > maxResult) {
            maxResult = candidate.votes;
          }
        })
        return maxResult;
      },
      updateInfo: (updatedDate) => {
        if (updatedDate === undefined) {
          return 'vor weniger als einer Minute';
        }
        let updated = new Date(updatedDate);
        if (updated.getTime()) {
          let now = new Date();
          let diff = now.getTime() + now.getTimezoneOffset() - updated.getTime(); // "updated" of q item already in UTC => "now" has to be normalized with timezone offset
          let diffMinutes = Math.floor(diff / (1000 * 60));
          if (diffMinutes < 60) { // update less than an hour ago
            return `vor ${diffMinutes} Minute${diffMinutes > 1 || diffMinutes === 0 ? 'n' : ''}`;
          } else if (diffMinutes < 60 * 24) { // update less than a day ago
            let hours = Math.floor(diffMinutes / 60);
            return `vor ${hours} Stunde${hours > 1 || hours === 0 ? 'n' : ''}`;
          } else if (diffMinutes > 7 * 60 * 24) { // update more than 7 days ago -> show date
            return `am ${date.getDate()}.${date.getMonth() + 1}.${date.getFullYear()}`;
          } else {
            let days = Math.floor(diffMinutes / (60 * 24));
            return `vor ${days} Tag${days > 1 || days === 0 ? 'en' : ''}`;
          }
        }
      },
      numberCandidates: (candidates) => {
        return candidates.length;
      }
    }
  };
</script>

