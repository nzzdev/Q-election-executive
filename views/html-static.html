<div class="q-item-container">
  <h3 class="s-q-item__title">{{title}}</h3>
  <Header subtitle='{{subtitle}}' resultStatus='{{resultStatus}}' updatedDate='{{updatedDate}}'/>
  <div class="q-election-executive">
    <MajorityInfo majority='{{majority}}' maxResult='{{enhancedCandidates.candidatesInfo.maxResult}}' />
    <Candidates candidates ='{{enhancedCandidates}}' />
  </div>
  <Footer majority='{{majority}}' candidatesInfo='{{enhancedCandidates.candidatesInfo}}' sources='{{sources}}' notes='{{notes}}' />
</div>

<script>
  import Header from './Header.html';
  import MajorityInfo from './MajorityInfo.html';
  import Candidates from './Candidates.html';
  import Footer from './Footer.html';

  export default {
    computed: {
      sortedCandidates: (candidates) => {
        return candidates.sort(function(candidateA, candidateB) {
          if ((candidateA.votes === undefined && candidateB.votes === undefined) || candidateA.votes === candidateB.votes) {
            return 0;
          }
          if ((candidateA.votes === undefined && candidateB.votes !== undefined) || (candidateA.votes < candidateB.votes)) {
            return 1;
          }
          return -1;
        })
      },
      enhancedCandidates: (sortedCandidates, majority) => {
        // enhance candidates object with additional information
        let isPrevious = false;
        let isElected = false;
        let isDropped = false;

        // if there are already any votes the first candidate 
        // of sorted list of candidates has max votes
        let maxResult = 0;
        if (sortedCandidates[0] && sortedCandidates[0].votes) {
          maxResult = sortedCandidates[0].votes;
        }

        sortedCandidates.forEach(candidate => {
          // define width and color of each candidate's bar
          let width = '1px';
          let colorStyle = '';
          let colorClass = '';
          if (maxResult > 0 && candidate.votes && candidate.votes > 0) {
            let widthPercentage = candidate.votes * 100 / maxResult;
            width = widthPercentage + '%';
          }
          candidate.width = width;
          if (candidate.color) {
            let colorDef;
            if (candidate.status === "elected" || candidate.status === "undefined") {
              colorDef = 'full';
            } else {
              colorDef = 'light';
            }
            if (candidate.color[colorDef]) {
              if (candidate.color[colorDef].classAttribute) {
                colorClass = candidate.color[colorDef].classAttribute;
              } else {
                colorStyle = 'background-color: ' + candidate.color[colorDef].colorCode + ';'; 
              }
            }
          }
          candidate.colorClass = colorClass;
          candidate.colorStyle = colorStyle;
          
          // check if we have previous, elected or dropped candidates for footer info
          if(candidate.isPrevious) {
            isPrevious = true;
            if (candidate.status === "not elected") {
              isDropped = true; 
            }
          }
          if (candidate.status === "elected") {
            isElected = true;
          }
        })

        sortedCandidates.candidatesInfo = {
          maxResult: maxResult,
          isPrevious: isPrevious,
          isElected: isElected,
          isDropped: isDropped
        };

        return sortedCandidates;
      }
    },

    components: {
      Header,
      MajorityInfo,
      Candidates,
      Footer
    }
  };
</script>

